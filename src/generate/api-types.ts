/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/py/generateERC7730": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Run Erc7730
         * @description Generate the 'erc7730' based on an ABI.
         */
        post: operations["run_erc7730_api_py_generateERC7730_post"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * AddressNameType
         * @description The type of address to display. Restrict allowable sources of names and MAY lead to additional checks from wallets.
         * @enum {string}
         */
        AddressNameType: "wallet" | "eoa" | "contract" | "token" | "collection";
        /** Component */
        Component: {
            /** Name */
            name: string;
            /** Type */
            type: string;
            /** Internaltype */
            internalType?: string | null;
            /** Components */
            components?: components["schemas"]["Component"][] | null;
        };
        /** Constructor */
        Constructor: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "constructor";
            /** Name */
            name?: string | null;
            /** Inputs */
            inputs?: components["schemas"]["InputOutput"][] | null;
            /** Outputs */
            outputs?: components["schemas"]["InputOutput"][] | null;
            stateMutability?: components["schemas"]["StateMutability"] | null;
            /** Constant */
            constant?: boolean | null;
            /** Payable */
            payable?: boolean | null;
            /** Gas */
            gas?: number | null;
            /** Signature */
            signature?: string | null;
        };
        /**
         * DateEncoding
         * @description The encoding for a date.
         * @enum {string}
         */
        DateEncoding: "blockheight" | "timestamp";
        /**
         * EIP712Schema
         * @description EIP-712 message schema.
         */
        EIP712Schema: {
            /**
             * Primary Type
             * @description The identifier of the schema primary type.
             */
            primaryType: string;
            /**
             * Types
             * @description The schema types reachable from primary type.
             */
            types: {
                [key: string]: components["schemas"]["EIP712SchemaField"][];
            };
        };
        /**
         * EIP712SchemaField
         * @description EIP-712 schema field, which is a tuple of a name and a type.
         */
        EIP712SchemaField: {
            /**
             * Name
             * @description The EIP-712 field name.
             */
            name: string;
            /**
             * Type
             * @description The EIP-712 field type identifier.
             */
            type: string;
        };
        /** Error */
        Error: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "error";
            /** Name */
            name: string;
            /** Inputs */
            inputs: components["schemas"]["InputOutput"][];
            /** Signature */
            signature?: string | null;
        };
        /** Event */
        Event: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "event";
            /** Name */
            name: string;
            /** Inputs */
            inputs: components["schemas"]["InputOutput"][];
            /**
             * Anonymous
             * @default false
             */
            anonymous: boolean;
            /** Signature */
            signature?: string | null;
        };
        /** Fallback */
        Fallback: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "fallback";
            /** Name */
            name?: string | null;
            /** Inputs */
            inputs?: components["schemas"]["InputOutput"][] | null;
            /** Outputs */
            outputs?: components["schemas"]["InputOutput"][] | null;
            stateMutability?: components["schemas"]["StateMutability"] | null;
            /** Constant */
            constant?: boolean | null;
            /** Payable */
            payable?: boolean | null;
            /** Gas */
            gas?: number | null;
            /** Signature */
            signature?: string | null;
        };
        /**
         * FieldFormat
         * @description The format of the field, that will be used to format the field value in a human readable way.
         * @enum {string}
         */
        FieldFormat: "raw" | "addressName" | "calldata" | "amount" | "tokenAmount" | "nftName" | "date" | "duration" | "unit" | "enum";
        /** Function */
        Function: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "function";
            /** Name */
            name?: string | null;
            /** Inputs */
            inputs?: components["schemas"]["InputOutput"][] | null;
            /** Outputs */
            outputs?: components["schemas"]["InputOutput"][] | null;
            stateMutability?: components["schemas"]["StateMutability"] | null;
            /** Constant */
            constant?: boolean | null;
            /** Payable */
            payable?: boolean | null;
            /** Gas */
            gas?: number | null;
            /** Signature */
            signature?: string | null;
        };
        /** HTTPValidationError */
        HTTPValidationError: {
            /** Detail */
            detail?: components["schemas"]["ValidationError"][];
        };
        /**
         * InputAddressNameParameters
         * @description Address Names Formatting Parameters.
         */
        InputAddressNameParameters: {
            /**
             * Address Type
             * @description An array of expected types of the address. If set, the wallet SHOULD check that the address matches one of the types provided.
             */
            types?: (components["schemas"]["AddressNameType"][] | string) | null;
            /**
             * Trusted Sources
             * @description An array of acceptable sources for names. If set, the wallet SHOULD restrict name lookup to relevant sources.
             */
            sources?: (string[] | string) | null;
        };
        /**
         * InputCallDataParameters
         * @description Embedded Calldata Formatting Parameters.
         */
        InputCallDataParameters: {
            /**
             * Called Selector
             * @description The selector being called, if not contained in the calldata. Hex string representation.
             */
            selector?: string | null;
            /**
             * Callee Path
             * @description The path to the address of the contract being called by this embedded calldata. Exactly one of "calleePath" or "callee" must be set.
             */
            calleePath?: string | null;
            /**
             * Callee
             * @description The address of the contract being called by this embedded calldata, as a constant value. Exactly one of "calleePath" or "callee" must be set.
             */
            callee?: string | null;
        };
        /**
         * InputContract
         * @description The contract binding context is a set constraints that are used to bind the ERC7730 file to a specific smart
         *     contract.
         */
        InputContract: {
            /**
             * Deployments
             * @description An array of deployments describing where the contract is deployed. The target contract (Tx to orfactory) MUST match one of those deployments.
             */
            deployments: components["schemas"]["InputDeployment"][];
            /**
             * ABI
             * @description The ABI of the target contract. This can be either an array of ABI objects or an URL pointing tothe ABI.
             */
            abi: (components["schemas"]["Constructor"] | components["schemas"]["Event"] | components["schemas"]["Function"] | components["schemas"]["Fallback"] | components["schemas"]["Error"] | components["schemas"]["Receive"])[] | string;
            /**
             * Address Matcher
             * @description An URL of a contract address matcher that should be used to match the contract address.
             */
            addressMatcher?: string | null;
            /**
             * Factory Constraint
             * @description A factory constraint is used to check whether the target contract is deployed by a specifiedfactory.
             */
            factory?: components["schemas"]["InputFactory"] | null;
        };
        /**
         * InputContractContext
         * @description Contract Binding Context.
         *
         *     The contract binding context is a set constraints that are used to bind the ERC7730 file to a specific smart
         *     contract.
         */
        InputContractContext: {
            /**
             * Id
             * @description An internal identifier that can be used either for clarity specifying what the element is or as areference in device specific sections.
             */
            $id?: string | null;
            /**
             * Contract Binding Context
             * @description The contract binding context is a set constraints that are used to bind the ERC7730 file to aspecific smart contract.
             */
            contract: components["schemas"]["InputContract"];
        };
        /**
         * InputDateParameters
         * @description Date Formatting Parameters
         */
        InputDateParameters: {
            /**
             * Date Encoding
             * @description The encoding of the date.
             */
            encoding: components["schemas"]["DateEncoding"] | string;
        };
        /**
         * InputDeployment
         * @description A deployment describing where the contract is deployed.
         *
         *     The target contract (Tx to or factory) MUST match one of those deployments.
         */
        InputDeployment: {
            /**
             * Chain ID
             * @description The deployment EIP-155 chain id.
             */
            chainId: number;
            /**
             * Contract Address
             * @description The deployment contract address.
             */
            address: string;
        };
        /**
         * InputDisplay
         * @description Display Formatting Info Section.
         */
        InputDisplay: {
            /**
             * Common Formatter Definitions
             * @description A set of definitions that can be used to share formatting information between multiple messages / functions. The definitions can be referenced by the key name in an internal path.
             */
            definitions?: {
                [key: string]: components["schemas"]["InputFieldDefinition"];
            } | null;
            /**
             * List of field formats
             * @description The list includes formatting info for each field of a structure. This list is indexed by a key identifying uniquely the message's type in the abi. For smartcontracts, it is the selector of the function or its signature; and for EIP712 messages it is the primaryType of the message.
             */
            formats: {
                [key: string]: components["schemas"]["InputFormat"];
            };
        };
        /**
         * InputDomain
         * @description EIP 712 Domain Binding constraint.
         *
         *     Each value of the domain constraint MUST match the corresponding eip 712 message domain value.
         */
        InputDomain: {
            /**
             * Name
             * @description The EIP-712 domain name.
             */
            name?: string | null;
            /**
             * Version
             * @description The EIP-712 version.
             */
            version?: string | null;
            /**
             * Chain ID
             * @description The EIP-155 chain id.
             */
            chainId?: number | null;
            /**
             * Verifying Contract
             * @description The EIP-712 verifying contract address.
             */
            verifyingContract?: string | null;
        };
        /**
         * InputEIP712
         * @description EIP 712 Binding.
         *
         *     The EIP-712 binding context is a set of constraints that must be verified by the message being signed.
         */
        InputEIP712: {
            /**
             * Deployments
             * @description An array of deployments describing where the contract is deployed. The target contract (Tx to orfactory) MUST match one of those deployments.
             */
            deployments: components["schemas"]["InputDeployment"][];
            /**
             * EIP 712 Domain Binding constraint
             * @description Each value of the domain constraint MUST match the corresponding eip 712 message domain value.
             */
            domain?: components["schemas"]["InputDomain"] | null;
            /**
             * Domain Separator constraint
             * @description The domain separator value that must be matched by the message. In hex string representation.
             */
            domainSeparator?: string | null;
            /**
             * EIP-712 messages schemas
             * @description Schemas of all messages.
             */
            schemas: (components["schemas"]["EIP712Schema"] | string)[];
        };
        /**
         * InputEIP712Context
         * @description EIP 712 Binding.
         *
         *     The EIP-712 binding context is a set of constraints that must be verified by the message being signed.
         */
        InputEIP712Context: {
            /**
             * Id
             * @description An internal identifier that can be used either for clarity specifying what the element is or as areference in device specific sections.
             */
            $id?: string | null;
            /**
             * EIP 712 Binding
             * @description The EIP-712 binding context is a set of constraints that must be verified by the message beingsigned.
             */
            eip712: components["schemas"]["InputEIP712"];
        };
        /**
         * InputERC7730Descriptor
         * @description An ERC7730 Clear Signing descriptor.
         *
         *     This model is directly serializable back the original JSON document.
         *
         *     Specification: https://github.com/LedgerHQ/clear-signing-erc7730-registry/tree/master/specs
         *
         *     JSON schema: https://github.com/LedgerHQ/clear-signing-erc7730-registry/blob/master/specs/erc7730-v1.schema.json
         */
        InputERC7730Descriptor: {
            /**
             * $Schema
             * @description The schema that the document should conform to. This should be the URL of a version of the clear signing JSON schemas available under https://github.com/LedgerHQ/clear-signing-erc7730-registry/tree/master/specs
             */
            $schema?: string | null;
            /**
             * Binding Context Section
             * @description The binding context is a set of constraints that are used to bind the ERC7730 file to a specificstructured data being displayed. Currently, supported contexts include contract-specificconstraints or EIP712 message specific constraints.
             */
            context: components["schemas"]["InputContractContext"] | components["schemas"]["InputEIP712Context"];
            /**
             * Metadata Section
             * @description The metadata section contains information about constant values relevant in the scope of thecurrent contract / message (as matched by the `context` section)
             */
            metadata: components["schemas"]["InputMetadata"];
            /**
             * Display Formatting Info Section
             * @description The display section contains all the information needed to format the data in a human readableway. It contains the constants and formatters used to display the data contained in the bound structure.
             */
            display: components["schemas"]["InputDisplay"];
        };
        /**
         * InputEnumParameters
         * @description Enum Formatting Parameters.
         */
        InputEnumParameters: {
            /**
             * Enum reference
             * @description The internal path to the enum definition used to convert this value.
             */
            $ref: string;
        };
        /**
         * InputFactory
         * @description A factory constraint is used to check whether the target contract is deployed by a specified factory.
         */
        InputFactory: {
            /**
             * Deployments
             * @description An array of deployments describing where the contract is deployed. The target contract (Tx to orfactory) MUST match one of those deployments.
             */
            deployments: components["schemas"]["InputDeployment"][];
            /**
             * Deploy Event signature
             * @description The event signature that the factory emits when deploying a new contract.
             */
            deployEvent: string;
        };
        /**
         * InputFieldDefinition
         * @description A field formatter, containing formatting information of a single field in a message.
         */
        InputFieldDefinition: {
            /**
             * Id
             * @description An internal identifier that can be used either for clarity specifying what the element is or as a reference in device specific sections.
             */
            $id?: string | null;
            /**
             * Field Label
             * @description The label of the field, that will be displayed to the user in front of the formatted field value.
             */
            label: string;
            /**
             * Field Format
             * @description The format of the field, that will be used to format the field value in a human readable way.
             */
            format?: components["schemas"]["FieldFormat"] | null;
            /**
             * Format Parameters
             * @description Format specific parameters that are used to format the field value in a human readable way.
             */
            params?: (components["schemas"]["InputAddressNameParameters"] | components["schemas"]["InputCallDataParameters"] | components["schemas"]["InputTokenAmountParameters"] | components["schemas"]["InputNftNameParameters"] | components["schemas"]["InputDateParameters"] | components["schemas"]["InputUnitParameters"] | components["schemas"]["InputEnumParameters"]) | null;
        };
        /**
         * InputFieldDescription
         * @description A field formatter, containing formatting information of a single field in a message.
         */
        InputFieldDescription: {
            /**
             * Id
             * @description An internal identifier that can be used either for clarity specifying what the element is or as a reference in device specific sections.
             */
            $id?: string | null;
            /**
             * Field Label
             * @description The label of the field, that will be displayed to the user in front of the formatted field value.
             */
            label: string;
            /**
             * Field Format
             * @description The format of the field, that will be used to format the field value in a human readable way.
             */
            format?: components["schemas"]["FieldFormat"] | null;
            /**
             * Format Parameters
             * @description Format specific parameters that are used to format the field value in a human readable way.
             */
            params?: (components["schemas"]["InputAddressNameParameters"] | components["schemas"]["InputCallDataParameters"] | components["schemas"]["InputTokenAmountParameters"] | components["schemas"]["InputNftNameParameters"] | components["schemas"]["InputDateParameters"] | components["schemas"]["InputUnitParameters"] | components["schemas"]["InputEnumParameters"]) | null;
            /**
             * Path
             * @description A path to the field in the structured data. The path is a JSON path expression that can be used to extract the field value from the structured data. Exactly one of "path" or "value" must be set.
             */
            path?: string | null;
            /**
             * Value
             * @description A literal value on which the format should be applied instead of looking up a field in the structured data. Exactly one of "path" or "value" must be set.
             */
            value?: string | number | boolean | null;
        };
        /**
         * InputFormat
         * @description A structured data format specification, containing formatting information of fields in a single type of message.
         */
        InputFormat: {
            /**
             * Id
             * @description An internal identifier that can be used either for clarity specifying what the element is or as a reference in device specific sections.
             */
            $id?: string | null;
            /**
             * Intent Message
             * @description A description of the intent of the structured data signing, that will be displayed to the user.
             */
            intent?: string | {
                [key: string]: string;
            } | null;
            /**
             * Screens grouping information
             * @description Screens section is used to group multiple fields to display into screens. Each key is a wallet type name. The format of the screens is wallet type dependent, as well as what can be done (reordering fields, max number of screens, etc...). See each wallet manufacturer documentation for more information.
             */
            screens?: {
                [key: string]: components["schemas"]["Screen"][];
            } | null;
            /**
             * Field Formats set
             * @description An array containing the ordered definitions of fields formats.
             */
            fields: (components["schemas"]["InputReference"] | components["schemas"]["InputFieldDescription"] | components["schemas"]["InputNestedFields"])[];
            /**
             * Required fields
             * @description A list of fields that are required to be displayed to the user. A field that has a formatter and is not in this list is optional. A field that does not have a formatter should be silent, ie not shown.
             */
            required?: (string)[] | null;
            /**
             * Excluded fields
             * @description Intentionally excluded fields, as an array of *paths* referring to specific fields. A field that has no formatter and is not declared in this list MAY be considered as an error by the wallet when interpreting the descriptor. The excluded paths should interpreted as prefixes, meaning that all fields under excluded path should be ignored
             */
            excluded?: string[] | null;
        };
        /**
         * InputMetadata
         * @description Metadata Section.
         *
         *     The metadata section contains information about constant values relevant in the scope of the current contract /
         *     message (as matched by the `context` section)
         */
        InputMetadata: {
            /**
             * Owner display name.
             * @description The display name of the owner or target of the contract / message to be clear signed.
             */
            owner?: string | null;
            /**
             * Main contract's owner detailed information.
             * @description The owner info section contains detailed information about the owner or target of the contract / message to be clear signed.
             */
            info?: components["schemas"]["OwnerInfo"] | null;
            /**
             * Token Description
             * @description A description of an ERC20 token exported by this format, that should be trusted. Not mandatory if the corresponding metadata can be fetched from the contract itself.
             */
            token?: components["schemas"]["TokenInfo"] | null;
            /**
             * Constant values
             * @description A set of values that can be used in format parameters. Can be referenced with a path expression like $.metadata.constants.CONSTANT_NAME
             */
            constants?: {
                [key: string]: string | number | boolean | null;
            } | null;
            /**
             * Enums
             * @description A set of enums that are used to format fields replacing values with human readable strings.
             */
            enums?: {
                [key: string]: string | {
                    [key: string]: string;
                };
            } | null;
        };
        /**
         * InputNestedFields
         * @description A single set of field formats, allowing recursivity in the schema.
         *
         *     Used to group whole definitions for structures for instance. This allows nesting definitions of formats, but note
         *     that support for deep nesting will be device dependent.
         */
        InputNestedFields: {
            /**
             * Path
             * @description A path to the field in the structured data. The path is a JSON path expression that can be used to extract the field value from the structured data. Exactly one of "path" or "value" must be set.
             */
            path?: string | null;
            /**
             * Value
             * @description A literal value on which the format should be applied instead of looking up a field in the structured data. Exactly one of "path" or "value" must be set.
             */
            value?: string | number | boolean | null;
            /**
             * Fields
             * @description Nested fields formats.
             */
            fields: (components["schemas"]["InputReference"] | components["schemas"]["InputFieldDescription"] | components["schemas"]["InputNestedFields"])[];
        };
        /**
         * InputNftNameParameters
         * @description NFT Names Formatting Parameters.
         */
        InputNftNameParameters: {
            /**
             * Collection Path
             * @description The path to the collection in the structured data. Exactly one of "collectionPath" or "collection" must be set.
             */
            collectionPath?: string | null;
            /**
             * Collection
             * @description The address of the collection contract, as a constant value. Exactly one of "collectionPath" or "collection" must be set.
             */
            collection?: string | null;
        };
        /** InputOutput */
        InputOutput: {
            /** Name */
            name: string;
            /** Type */
            type: string;
            /** Internaltype */
            internalType?: string | null;
            /** Components */
            components?: components["schemas"]["Component"][] | null;
            /** Indexed */
            indexed?: boolean | null;
            /** Unit */
            unit?: string | null;
        };
        /**
         * InputReference
         * @description A reference to a shared definition that should be used as the field formatting definition.
         *
         *     The value is the key in the display definitions section, as a path expression $.display.definitions.DEFINITION_NAME.
         *     It is used to share definitions between multiple messages / functions.
         */
        InputReference: {
            /**
             * Path
             * @description A path to the field in the structured data. The path is a JSON path expression that can be used to extract the field value from the structured data. Exactly one of "path" or "value" must be set.
             */
            path?: string | null;
            /**
             * Value
             * @description A literal value on which the format should be applied instead of looking up a field in the structured data. Exactly one of "path" or "value" must be set.
             */
            value?: string | number | boolean | null;
            /**
             * Internal Definition
             * @description An internal definition that should be used as the field formatting definition. The value is the key in the display definitions section, as a path expression $.display.definitions.DEFINITION_NAME.
             */
            $ref: string;
            /**
             * Field Label
             * @description The label of the field, that will be displayed to the user in front of the formatted field value. Overrides the label in the referenced definition if set.
             */
            label?: string | null;
            /**
             * Parameters
             * @description Parameters override. These values takes precedence over the ones in the definition itself.
             */
            params?: Record<string, never> | null;
        };
        /**
         * InputTokenAmountParameters
         * @description Token Amount Formatting Parameters.
         */
        InputTokenAmountParameters: {
            /**
             * Token Path
             * @description Path reference to the address of the token contract. Used to associate correct ticker. If ticker is not found or tokenPath is not set, the wallet SHOULD display the raw value instead with an"Unknown token" warning. Exactly one of "tokenPath" or "token" must be set.
             */
            tokenPath?: string | null;
            /**
             * Token
             * @description The address of the token contract, as constant value. Used to associate correct ticker. If ticker is not found or value is not set, the wallet SHOULD display the raw value instead with an "Unknown token" warning. Exactly one of "tokenPath" or "token" must be set.
             */
            token?: string | null;
            /**
             * Native Currency Address
             * @description An address or array of addresses, any of which are interpreted as an amount in native currency rather than a token.
             */
            nativeCurrencyAddress?: (string)[] | string | null;
            /**
             * Unlimited Threshold
             * @description The threshold above which the amount should be displayed using the message parameter rather than the real amount (encoded as an int or byte array).
             */
            threshold?: string | number | null;
            /**
             * Unlimited Message
             * @description The message to display when the amount is above the threshold.
             */
            message?: string | null;
        };
        /**
         * InputUnitParameters
         * @description Unit Formatting Parameters.
         */
        InputUnitParameters: {
            /**
             * Unit base symbol
             * @description The base symbol of the unit, displayed after the converted value. It can be an SI unit symbol or acceptable dimensionless symbols like % or bps.
             */
            base: string;
            /**
             * Decimals
             * @description The number of decimals of the value, used to convert to a float.
             */
            decimals?: number | string | null;
            /**
             * Prefix
             * @description Whether the value should be converted to a prefixed unit, like k, M, G, etc.
             */
            prefix?: boolean | string | null;
        };
        /** Message */
        Message: {
            /** Message */
            message: string;
        };
        /**
         * OwnerInfo
         * @description Main contract's owner detailed information.
         *
         *     The owner info section contains detailed information about the owner or target of the contract / message to be
         *     clear signed.
         */
        OwnerInfo: {
            /**
             * Owner Legal Name
             * @description The full legal name of the owner if different from the owner field.
             */
            legalName: string;
            /**
             * Last Update of the contract / message
             * @description The date of the last update of the contract / message.
             */
            lastUpdate?: string | null;
            /**
             * Owner URL
             * Format: uri
             * @description URL with more info on the entity the user interacts with.
             */
            url: string;
        };
        /** Props */
        Props: {
            /** Abi */
            abi?: string | null;
            /** Address */
            address?: string | null;
            /** Chain Id */
            chain_id?: number | null;
        };
        /** Receive */
        Receive: {
            /**
             * @description discriminator enum property added by openapi-typescript
             * @enum {string}
             */
            type: "receive";
            /** Name */
            name?: string | null;
            /** Inputs */
            inputs?: components["schemas"]["InputOutput"][] | null;
            /** Outputs */
            outputs?: components["schemas"]["InputOutput"][] | null;
            stateMutability?: components["schemas"]["StateMutability"] | null;
            /** Constant */
            constant?: boolean | null;
            /** Payable */
            payable?: boolean | null;
            /** Gas */
            gas?: number | null;
            /** Signature */
            signature?: string | null;
        };
        /**
         * Screen
         * @description Screens section is used to group multiple fields to display into screens. Each key is a wallet type name. The
         *     format of the screens is wallet type dependent, as well as what can be done (reordering fields, max number of
         *     screens, etc...). See each wallet manufacturer documentation for more information.
         */
        Screen: Record<string, never>;
        /**
         * StateMutability
         * @enum {string}
         */
        StateMutability: "pure" | "view" | "nonpayable" | "payable";
        /**
         * TokenInfo
         * @description Token Description.
         *
         *     A description of an ERC20 token exported by this format, that should be trusted. Not mandatory if the
         *     corresponding metadata can be fetched from the contract itself.
         */
        TokenInfo: {
            /**
             * Token Name
             * @description The token display name.
             */
            name: string;
            /**
             * Token Ticker
             * @description A short capitalized ticker for the token, that will be displayed in front of corresponding amounts.
             */
            ticker: string;
            /**
             * Token Decimals
             * @description The number of decimals of the token ticker, used to display amounts.
             */
            decimals: number;
        };
        /** ValidationError */
        ValidationError: {
            /** Location */
            loc: (string | number)[];
            /** Message */
            msg: string;
            /** Error Type */
            type: string;
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    run_erc7730_api_py_generateERC7730_post: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody: {
            content: {
                "application/json": components["schemas"]["Props"];
            };
        };
        responses: {
            /** @description Successful Response */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["InputERC7730Descriptor"];
                };
            };
            /** @description Bad Request */
            400: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Message"];
                };
            };
            /** @description Validation Error */
            422: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["HTTPValidationError"];
                };
            };
        };
    };
}
